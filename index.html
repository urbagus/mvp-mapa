<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MVP Mapa - Accesibilidad + Población + EPV</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }
    .leaflet-control-layers { max-height: 65vh; overflow: auto; }

    .legend {
      background: white;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,.15);
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .legend .row { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .legend .swatch { width: 14px; height: 14px; border-radius: 3px; }
    .legend .title { font-weight: 600; margin-bottom: 6px; }
    .legend .muted { color: #666; font-size: 11px; margin-top: 6px; }
  </style>
</head>

<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // =========================
    // CONFIG
    // =========================
    const ACCESS_URL = "./data/hex_index_access.geojson";
    const POP_URL    = "./data/hex_index_pop.geojson";
    const EPV_URL    = "./data/epv.geojson"; // <-- CAMBIAR si tu archivo se llama distinto

    // Join entre access y pop
    const JOIN_KEY  = "id";
    const ACC_FIELD = "acc_index";
    const POP_FIELD = "pop_hex";

    // EPV
    const EPV_GRADE_FIELD = "tabla_EPV_S_GRADO_CALIDAD";

    // Intensidad por población
    const NEUTRAL = "#f3f3f3";
    const BASE_OPACITY = 0.90;
    const GAMMA = 1.25;

    // =========================
    // Basemaps
    // =========================
    const baseLight = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
      { maxZoom: 20, attribution: "&copy; OpenStreetMap &copy; CARTO" }
    );

    const baseDark = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      { maxZoom: 20, attribution: "&copy; OpenStreetMap &copy; CARTO" }
    );

    const map = L.map("map", { layers: [baseLight], preferCanvas: true })
      .setView([-32.95, -60.66], 12);

    // =========================
    // Utils
    // =========================
    function lerp(a, b, t) { return a + (b - a) * t; }

    function hexToRgb(hex) {
      const h = hex.replace("#", "");
      return { r: parseInt(h.slice(0,2), 16), g: parseInt(h.slice(2,4), 16), b: parseInt(h.slice(4,6), 16) };
    }

    function rgbToCss({r,g,b}) { return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`; }

    function mixHex(c1, c2, t) {
      const a = hexToRgb(c1), b = hexToRgb(c2);
      return rgbToCss({ r: lerp(a.r, b.r, t), g: lerp(a.g, b.g, t), b: lerp(a.b, b.b, t) });
    }

    function quantileBreaks(values, k) {
      const v = values.slice().sort((a,b) => a-b);
      const breaks = [];
      for (let i = 1; i < k; i++) {
        const idx = Math.floor((i * v.length) / k);
        breaks.push(v[Math.min(idx, v.length - 1)]);
      }
      return breaks;
    }

    function classIndex(x, breaks) {
      for (let i = 0; i < breaks.length; i++) if (x <= breaks[i]) return i;
      return breaks.length;
    }

    function formatNum(n) {
      if (n == null || Number.isNaN(n)) return "—";
      return (Math.round(n * 1000) / 1000).toString();
    }

    function toNumber(v) {
      if (v == null) return NaN;
      if (typeof v === "number") return v;
      const s = String(v).trim().replace(/\s/g, "");
      if (s.includes(",") && !s.includes(".")) return Number(s.replace(",", "."));
      if (s.includes(",") && s.includes(".")) return Number(s.replace(/\./g, "").replace(",", "."));
      return Number(s);
    }

    // Palette RdYlGn 10 clases
    const colors = [
      "#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b",
      "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"
    ];

    // Leyenda acc_index cuantiles
    function addLegend(breaks) {
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function() {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `<div class="title">${ACC_FIELD} (cuantiles) + intensidad por ${POP_FIELD}</div>`;
        let prev = null;

        for (let i = 0; i < colors.length; i++) {
          const to = (i < breaks.length) ? breaks[i] : null;
          const label = (to == null)
            ? `> ${formatNum(prev)}`
            : (prev == null ? `≤ ${formatNum(to)}` : `${formatNum(prev)} – ${formatNum(to)}`);

          div.innerHTML += `
            <div class="row">
              <span class="swatch" style="background:${colors[i]}"></span>
              <span>${label}</span>
            </div>`;
          prev = to;
        }
        div.innerHTML += `<div class="muted">10 clases. Población modula saturación/opacidad.</div>`;
        return div;
      };
      legend.addTo(map);
      return legend;
    }

    // =========================
    // Render
    // =========================
    const overlays = {};

    Promise.all([
      fetch(ACCESS_URL).then(r => { if(!r.ok) throw new Error(`HTTP ${r.status} ${ACCESS_URL}`); return r.json(); }),
      fetch(POP_URL).then(r => { if(!r.ok) throw new Error(`HTTP ${r.status} ${POP_URL}`); return r.json(); }),
      fetch(EPV_URL).then(r => { if(!r.ok) throw new Error(`HTTP ${r.status} ${EPV_URL}`); return r.json(); }),
    ])
    .then(([accData, popData, epvData]) => {

      // ---- 1) Población por id
      const popById = new Map();
      const popVals = [];

      for (const f of popData.features || []) {
        const id = f?.properties?.[JOIN_KEY];
        const p  = toNumber(f?.properties?.[POP_FIELD]);
        if (id == null) continue;
        if (!Number.isNaN(p)) {
          popById.set(String(id), p);
          popVals.push(p);
        }
      }
      if (!popVals.length) throw new Error(`No encontré población numérica en properties.${POP_FIELD}`);

      // ---- 2) Cuantiles de acc_index
      const accVals = [];
      for (const f of accData.features || []) {
        const v = toNumber(f?.properties?.[ACC_FIELD]);
        if (!Number.isNaN(v)) accVals.push(v);
      }
      if (!accVals.length) throw new Error(`No encontré valores numéricos en properties.${ACC_FIELD}`);

      const accBreaks = quantileBreaks(accVals, 10);

      // ---- 3) Escala población -> t (0..1) con p10..p90 + log
      popVals.sort((a,b)=>a-b);
      const p10 = popVals[Math.floor(popVals.length * 0.10)];
      const p90 = popVals[Math.floor(popVals.length * 0.90)];

      function popToT(p) {
        if (p == null || Number.isNaN(p)) return 0;
        const lp  = Math.log1p(p);
        const l10 = Math.log1p(p10);
        const l90 = Math.log1p(p90);
        let t = (lp - l10) / (l90 - l10);
        t = Math.max(0, Math.min(1, t));
        return Math.pow(t, GAMMA);
      }

      // ---- 4) Capa combinada (acc * población)
      function styleCombined(feature) {
        const id  = String(feature?.properties?.[JOIN_KEY] ?? "");
        const acc = toNumber(feature?.properties?.[ACC_FIELD]);
        const pop = popById.get(id);

        let baseColor = "#cccccc";
        if (!Number.isNaN(acc)) {
          const idx = classIndex(acc, accBreaks);
          baseColor = colors[idx];
        }

        const t = popToT(pop);

        return {
          stroke: false,
          fillColor: mixHex(NEUTRAL, baseColor, t),
          fillOpacity: BASE_OPACITY * (0.10 + 0.90 * t)
        };
      }

      const layerAccPop = L.geoJSON(accData, { style: styleCombined }).addTo(map);
      overlays["Acc+Pob (modulado)"] = layerAccPop;

      // ---- 5) EPV por grado de calidad (subcapas)
      const gradesSet = new Set();
      for (const f of epvData.features || []) {
        const g = f?.properties?.[EPV_GRADE_FIELD];
        gradesSet.add(String(g ?? "Sin dato"));
      }
      const grades = Array.from(gradesSet).sort((a,b) => a.localeCompare(b, "es"));

      // estilos EPV
      function epvStyle() {
        return { weight: 1.2, opacity: 0.9, fillOpacity: 0.10 };
      }
      function epvPointToLayer(feature, latlng) {
        return L.circleMarker(latlng, { radius: 5, weight: 1.5, opacity: 0.9, fillOpacity: 0.65 });
      }

      // crea una capa por grade
      for (const grade of grades) {
        const sub = L.geoJSON(epvData, {
          filter: (feature) => String(feature?.properties?.[EPV_GRADE_FIELD] ?? "Sin dato") === grade,
          style: epvStyle,
          pointToLayer: epvPointToLayer,
        });
        overlays[`EPV: ${grade}`] = sub; // aparece como toggles en el control
        // (no las agrego por defecto para que no ensucie; si querés que una venga on, la .addTo(map))
      }

      // ---- Controles
      const baseMaps = { "Claro": baseLight, "Oscuro": baseDark };
      L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

      addLegend(accBreaks);

      // encuadre
      try { map.fitBounds(layerAccPop.getBounds(), { padding: [20, 20] }); } catch(e) {}

    })
    .catch(err => {
      console.error(err);
      alert("Error: " + err.message);
    });
  </script>
</body>
</html>
