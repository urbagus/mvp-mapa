<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MVP Mapa - Accesibilidad</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }

    /* opcional: la caja de layers un poco más usable */
    .leaflet-control-layers { max-height: 60vh; overflow: auto; }
  </style>
</head>

<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // --- Basemaps (estética dashboard)
    const baseLight = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
      { maxZoom: 20, attribution: "&copy; OpenStreetMap &copy; CARTO" }
    );

    const baseDark = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      { maxZoom: 20, attribution: "&copy; OpenStreetMap &copy; CARTO" }
    );

    // --- Mapa
    const map = L.map("map", { layers: [baseLight] })
      .setView([-32.95, -60.66], 12);

    // --- Color rojo -> verde según acc_index (0 a ~9.5)
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function getColor(v) {
      if (v == null || Number.isNaN(v)) return "#cccccc";

      const min = 0;
      const max = 9.5; // si querés lo ajustamos según tu dataset real
      const t = Math.max(0, Math.min(1, (v - min) / (max - min)));

      // gradiente rojo -> verde (suave)
      const r = Math.round(lerp(220, 34, t));
      const g = Math.round(lerp(50, 139, t));
      const b = Math.round(lerp(47, 34, t));

      return `rgb(${r},${g},${b})`;
    }

    function style(feature) {
      const vRaw = feature?.properties?.acc_index;
      const v = (vRaw === null || vRaw === undefined) ? null : Number(vRaw);

      return {
        weight: 0,          // sin borde (más limpio para hex)
        fillOpacity: 0.85,
        fillColor: getColor(v)
      };
    }

    // --- Cargar GeoJSON
    const overlays = {};

    fetch("./data/hex_index_access.geojson")
      .then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status} cargando GeoJSON`);
        return r.json();
      })
      .then(data => {
        const hexLayer = L.geoJSON(data, { style }).addTo(map);
        overlays["Accesibilidad (hex)"] = hexLayer;

        // encuadrar
        try {
          map.fitBounds(hexLayer.getBounds(), { padding: [20, 20] });
        } catch (e) {}

        // control de capas (base + overlay)
        const baseMaps = { "Claro": baseLight, "Oscuro": baseDark };
        L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);
      })
      .catch(err => {
        console.error(err);
        alert("No pude cargar el GeoJSON. Mirá la consola (F12). " + err.message);
      });
  </script>
</body>
</html>
